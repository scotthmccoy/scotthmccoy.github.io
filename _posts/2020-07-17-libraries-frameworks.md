---
layout: post
title: Libraries & Frameworks
date: 2020-07-17 10:17 -0700
---

## Files, Directories, Packages, Bundles and Frameworks
A `package` is any directory that the Finder presents to the user as if it were a single file.
Finder considers a directory to be a package if **any** of the following conditions are true:
1. The directory has a known filename extension: .app, .bundle, .framework, .plugin, .kext, and so on.
2. The directory has an extension that some other application claims represents a package type; see Document Packages.
3. The directory has its package bit set.
A `bundle` is type of `package` with a standardized hierarchical structure that holds executable code and the resources used by that code. Apps and `frameworks` are examples of `bundles`.


## Libraries vs Frameworks
* A `Library` is a collection of `object files` which are compiled .m files outputed by Clang as a .o file. (Author's note: presumably .swift files are compiled into .o files as well, but I haven't checked.) Like gcc, Clang is a compiler for the c-family of languages and is backed by the LLVM compiler infrastructure which stands for "Low Level Virtual Machine" despite it [not being a Virtual Machine](https://llvm.org/). `Object files` contain symbols for the linker to piece together into a `Mach-O Object File` (see below).  
* A `Framework` is a type of `bundle` containing a static or dynamic `library` and its resources.
* So, a `Framework` is a `bundle` (which is also a `package`) that contains a `library` which is a collection of `object files`.



## Mach-O Object Files & Types
Distinct from an `object file` generated by clang, these `Macho-O Object Files` are the various [options for output from Xcode's linker phase](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html) under Build Settings -> Linking -> Mach-O type. The most significant to this writing are `Static Library` and `Dynamic Library`, which inform how a Library or Framework may be linked by its consumer:

![]({{site.url}}/images/libraries_frameworks__mach_o_types.png)


## Static vs Dynamic

| | Static  | Dynamic |
|-|---------|---------|
| Library   | ![]({{site.url}}/images/libraries_frameworks__static_library.png) A **.a** file linked by the Static Linker at compile time. Must be shipped with header files. | ![]({{site.url}}/images/libraries_frameworks__dynamic_library.png) A **.dylib** file linked by the Dynamic Linker, or  `dyld` as-needed at runtime. The advantage is that libraries can be shared and don't take up space in each app. For example, all iOS and macOS system libraries are dynamic. The disadvantage is a slower launch/run time since the linking phase must occur during runtime. |
| Framework | ![]({{site.url}}/images/libraries_frameworks__static_framework.png) A `package` with the **.framework** extension containing a Static Library and its headers and other resources. Linked at compile time. | ![]({{site.url}}/images/libraries_frameworks__dynamic_framework.png) A `package` with the **.framework** extension containing a Dynamic Library and its headers and other resources. These must either be made available by the operating system (As all iOS and MacOS libraries/frameworks are) or be `embedded` into the App's bundle. |

## Potential Gains from switching to From Dynamic to Static Libs/Frameworks
In an example using 27 frameworks, [this dev](https://medium.com/@acecilia/static-vs-dynamic-frameworks-in-swift-an-in-depth-analysis-ff61a77eec65):
1. **Reduced app size 14.55%**. They theorized this was due to the compiler being able to remove unused symbols which is not possible when using dynamic frameworks, and linked this [heated exchange](https://github.com/ReactiveX/RxSwift/pull/1960) for reference. 
2. **Reduced first-launch load time by about 37.5%**. Subsequent launches were comparable thanks to the dyld cache.

Though the first-launch speed gains are worth pursuing, the size gains should only affect Swift libraries/frameworks since an Objective-C static library aught to be passed to the linker with the -ObjC option specified which "Loads all members of static archive libraries that implement an Objective-C class or category" since one of ObjC's strengths/weaknesses is that it loads the entire symbol table and you can send any message to any object.

From [https://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library](https://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library)
> To resolve this issue, the static library should pass the -ObjC option to the linker. This flag causes the linker to load every object file in the library that defines an Objective-C class or category. While this option will typically result in a larger executable (due to additional object code loaded into the application), it will allow the successful creation of effective Objective-C static libraries that contain categories on existing classes.

## Static vs Dynamic Frameworks and Swift
* It used to be the case that a framework that used Swift **had to** be dynamic, probably because the Swift libraries must be included in the framework package because of Swifts ABI instability prior to 5.0, and the fact that because they were system libraries, they were distributed as dylibs. 
* ABI Stability came with Swift 5 in Xcode 10.2 (March of 2019). This allowed the App Store to [thin app downloads](https://developer.apple.com/documentation/xcode-release-notes/swift-5-release-notes-for-xcode-10_2) of their Swift dylibs so long as the device is running iOS 12.2 or higher (and thus came with the Swift dylibs already installed). For prior iOS versions, the Swift dylibs would still have to be included in the app and downloaded by the user.
* Module Stability came in Swift 5.1 with Xcode 11.0 (September of 2019). This allowed true [backwards compatibility](https://www.donnywals.com/what-is-module-stability-in-swift-and-why-should-you-care/) with prior versions of Swift (at the time, only 5.0 and 5.0.1):
> While ABI Stability allows programs written with different versions of Swift to exist in a shared runtime, Module Stability allows you to use frameworks compiled with different versions of Swift in a project that might use yet another version of Swift.
* You can now make a Swift static library. This [article](https://medium.com/onfido-tech/distributing-compiled-ios-swift-static-libraries-and-swift-static-frameworks-7fecc4f3d182) gives pretty detailed instructions, including what to do with the .swiftmodule. 

## Swift in a Framework Still Not a Good Idea
And it probably won't be until most major apps are on Swift 5.1+ and/or until iOS 12.1 dies.

If the framework uses Swift 5.1+, the host app uses Swift 5.0+, and the app targets iOS 12.2 or higher, you're golden. But, big apps tend to target very low iOS versions so a framework has to target 12.1 and lower (and thus include the Swift dylibs) to be of any real value to the world. Users on 12.1 and lower then have to download them, potentially twice if the framework and app have differing Swift versions (which may not even be compatible with each other if one of those is prior to 5.1). It's possible that app thinning doesn't extend to removing redundant versions of the same dylibs in which case the user would have to download them twice even if the Swift versions matched. This seems to be somewhat implied by "Apps using bundled runtimes will however not get the benefits of App Store app thinning" on [this page](https://swift.org/blog/abi-stability-and-apple/). 

So, we're effectively in the same boat we were in back in 2017 or 2018: Using swift in a framework has the potential for incompatibility with the host app and may increase download sizes by about 5 megs.  

Assuming that 1 major version of iOS is dropped from general support per year and with iOS 9 finally getting killed off this year (2020), 12.1 may not be killed until 2022 or 2023 at which point we can finally write a framework in Swift and be able to guarantee that it won't cause these kinds of integration problems for a major publisher. It's likely that prior to that enough major publishers will adopt Swift 5.1+ that the balance shifts and it becomes the rule rather than the exception that a framework will be written in Swift, but I don't think we're there yet.


## Modules and Modulemaps

This [Video from WWDC 2013](https://developer.apple.com/videos/play/wwdc2013/404/) explains it very well:  The `#include` preprocessor directive just pastes the included file right into the code. The `#import` directive does the same but it checks if it has been included before. Since both essentially do a copypaste job, it can result in chaos if you accidentally `#define` something that the include/import uses (like strong or readonly). It also results in a cross-product increase in code size in the eyes of the compiler since most of your files grow by the size of the common includes:

![]({{site.url}}/images/libraries_frameworks__non_scalable_includes.png)

A Pre-Compiled Header *partially* addresses this by allowing you to compile the common code **once**, but they result in namespace pollution - parts of your code get access to things they don't need like a Json fetcher having access to UIKit. 

### Modules
Modules address the fragility and scalability problem of headers by encapsulating the framework. To make use of them, you use the  `@import` directive which does a "Semantic Import"; it loads the complete semantic definition of the framework, and the compiler compiles it *once* as an isolated unit. As such, it doesn't need to parse the headers and local macros have no effect on the the Framework's API. The `@import` directive also eliminates the need to add the framework via "Link Binary With Libraries"; the compiler adds it for you! You can also import only some of the module. For example, `@import iAd.AdBannerView` will only import iAds' banner view and  `@import iAd.AdInterstitialView` will only import its interstitials. For known modules (ones with a modulemap visible to the compiler), `#inlcude` and `#import` are automatically mapped to the equivalent `@import`.

### Example modulemap
![]({{site.url}}/images/libraries_frameworks__modulemap_example.png)
This says 
1. "Include UIKit.h", which is what you used to do anyways.
2. Next it says "Anything that I import is a submodule"
3. It also says "Link against the UIKit Framework"

### Modern Usage

In 2013, Xcode 5 added "Enable Modules" under Build Settings -> Apple Clang - Language - Modules. This is set to Yes by default. Later in In 2014 with Xcode 6, support for user-defined modules was added, and "Defines Module" is now set to Yes by default. Thus, any modern user-defined framework project has a modulemap and can be imported via `@import`. [This article](http://blog.bjhomer.com/2015/05/defining-modules-for-custom-libraries.html) static modules, but I have not tested to see if it works or if the steps are still necessary.

### Mixing Swift & Objective C in a Framework
This requires the use of a modulemap because bridging headers can't be used inside framework projects. [Example](https://medium.com/allatoneplace/challenges-building-a-swift-framework-d882867c97f9). 


## Defunct Topics

### Real versus Fake Frameworks
You can safely skip this section as this distinction is no longer of any real significance, Xcode having fixed this bug(?) in 2014 with the release of Xcode 6. 

In disallowing dynamically linked libraries for iOS Apple accidentally(?) removed static iOS framework creation functionality. Developers responded with the "relocatable object file" bundle hack, which tricked Xcode into building something that mostly resembles a framework, but is really a bundle. Alternately, with some tweaking of Xcode itself you could add the ability to create a static iOS framework back into Xcode using this plugin: [iOS-Universal-Framework](https://github.com/kstenerud/iOS-Universal-Framework). 

### Umbrella Framework
A framework that contains other frameworks. It is [possible but not officially supported on iOS](https://medium.com/@andreamiotz/ios-umbrella-framework-with-cocoapods-57d2d3c2daa9). Normally, when you create a framework which has a dependency, the app is responsible for adding that dependency along with your framework into the project.

### Code Signing a Framework
According to [this Stackoverflow post](https://stackoverflow.com/questions/30963294/creating-ios-osx-frameworks-is-it-necessary-to-codesign-them-before-distributin):
1. Xcode used to force you to code sign a framework when compiling it
2. Using `lipo` removes codesigning, which makes sense since it modifies the binary. 
3. Because of this, some of the most commonly distributed frameworks have *no* codesigning:
>Binary framework distributions of well-known open source projects on Github are not codesigned. Command codesign -d -vvvv gives: "code object is not signed at all" on all of the binary iOS and OSX frameworks I used to explore. Some examples: ReactiveCocoa and Mantle, Realm, PromiseKit.
4. As of Xcode 9.4 (May 2018), the IDE will ask you to disable code signing for iOS Cocoa Touch Frameworks. Apple now says it is not recommended that you code sign your .framework.

I don't remember ever coming accross code signing issues with frameworks, probably because the framework projects I've worked on always used `lipo` to alter the architecture slices in the binary before shipping.


## Cocoapods
By default, Cocoapods compiles all your pods into a big static library.  Prior to March 2019, Swift could not support static libraries because of Swift's ABI instability - the swift dylibs had to be included in th framework, forcing it to be a dynamic framework. Cocoapods thus offered the `use_frameworks!` directive which tells it to use dynamic frameworks 
instead of making a big static library. According to [Cocoapod's 0.36 Release Notes](https://blog.cocoapods.org/CocoaPods-0.36/),
>This is an all or nothing approach per integrated targets, because we can't ensure to properly build frameworks, whose transitive dependencies are static libraries.

However with with the ABI Stability offered by Swift 5 in Xcode 10.2 (March of 2019), swift static libraries finally became possible, and Cocoapods 1.5.0 (April 2019) offered `use_modular_headers!` instead. 
>In this release, you will be able to opt into stricter header search paths (and module map generation for Objective-C pods). As a pod author, you can add 'DEFINES_MODULE' => 'YES' to your pod_target_xcconfig. Alternatively, in your Podfile you can add use_modular_headers! to enable the stricter search paths and module map generation for all of your pods, or you can add :modular_headers => true to a single pod declaration to enable for only that pod.

### MoPub's Cocoapod

According to [this](http://onebigfunction.com/ios/2015/12/31/mopub-mo-problems/), using MoPub's Cocoapod in a swift project seem to require either adding MoPub to your bridging header or you're forced to use `use_frameworks!`, and laments that there's not a way to configure your Podfile such that it applies only to a single pod instead of your whole project. This is probably because MoPub is in the akward postion of wanting to support all of the following:

1. A source distribution
2. Objective-C Apps that don't want any Swift
3. Swift apps
4. Compilation as a framework

It seems like kind of a miss for such a well-established company to just imply that you should use `use_frameworks!` and end the conversation there, but given that their own [Canary project](https://github.com/mopub/mopub-ios-sdk/tree/master/Canary) has them using it, maybe it's just something they're not super aware of. 

### pod_target_xcconfig
This is where you can add 'DEFINES_MODULE' => 'YES'. Documented [here](https://guides.cocoapods.org/syntax/podspec.html#pod_target_xcconfig). According to [this](https://stackoverflow.com/questions/51227921/is-there-any-downside-to-setting-defines-module-yes-in-my-podspec) there's no real downside for doing so.

### frameworks
The `frameworks` directive in a podfile specifies [a list of system frameworks that the user’s target needs to link against](https://guides.cocoapods.org/syntax/podspec.html#frameworks).


### weak_frameworks
The `frameworks` directive in a podfile specifies [a list of frameworks that the user’s target needs to **weakly** link against](https://guides.cocoapods.org/syntax/podspec.html#frameworks). This means that the pod is written such that if the framework is not available it will still run.

[Example](https://stackoverflow.com/questions/23354840/what-does-weak-framework-mean-in-xcodes-build-settings):
>For example, one might want to mark SpriteKit as optional, so the app could still run on an OS that doesn't have it (for example, anything older than 7.0).
