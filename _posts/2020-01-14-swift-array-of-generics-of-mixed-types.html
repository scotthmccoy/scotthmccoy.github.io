---
layout: post
title: Swift - Array of Generics of mixed types (Don't!!)
date: '2020-01-14T12:03:00.000-08:00'
author: Scott McCoy
tags: 
modified_time: '2020-01-15T12:43:18.667-08:00'
blogger_id: tag:blogger.com,1999:blog-250956833460526415.post-5129331290565549229
blogger_orig_url: https://scotthmccoy.blogspot.com/2020/01/swift-array-of-generics-of-mixed-types.html
---

Most common data formats (Json, Plist, XML) support arrays of mixed types like: ["foo", 1, {"a":3}]<br /><br />I often find myself wanting to make a wrapper that provides functionality like CustomStringConvertible, serialization to UserDefaults and so forth and then make an array of it:<br /><br />let arr = [MyClass]()<br /><br />But I want to be able to tell what the instance of MyClass is wrapping, so I want MyClass to be generic:<br /><br />let firstElem = MyClass(1)<br />let secondElem = MyClass("Foo")<br /><br />let arr = [firstElem, secondElem]<br /><br />But this results in "Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional" since firstElem is of type MyClass&lt;Int&gt; and secondElem is of type MyClass&lt;String&gt;.<string>&nbsp;</string><br /><br />Making it an array of MyClass also doesn't work:<br />let arr:[MyClass] = [firstElem, secondElem] -&gt; "Cannot convert value of type 'MyClass<int>' to expected element type 'MyClass'""</int><br /><br />The compiler treats them as completely different data types!<br /><br />So what are some actual solutions?<br /><br /><br />1. Make an array of your class type but make the type parameter Any:<br /><br />let firstElem:MyClass<any> = MyClass(1)</any><br />let secondElem:MyClass<any> = MyClass("Foo")</any><br />arr:[MyClass<any>] = [</any><br /><span style="white-space: pre;"> </span>firstElem,<br /><span style="white-space: pre;"> </span>secondElem<br />]<br /><br />Note that this wipes out the utility of having MyClass even *be* generic since instances of it are now explicitly MyClass&lt;Any&gt;rather than a&nbsp;<int><int><string><string>MyClass&lt;Int&gt; and secondElem and MyClass&lt;String&gt;.</string></string></int></int><br /><br /><br />2. Make an array of Any:<br /><br />let arr:[Any] = [firstElem, secondElem]<br /><br />We get the benefits of generics, but the risk of an Any array.<br /><br />Note that it's tempting to try and hide the array inside a container and then gate access to it with a func:<br /><br />func add(item:MyClass) {<br />&nbsp; <br />}<br /><br />But this gets you a "Reference to generic type 'MyClass' requires arguments in &lt;...&gt;""<br /><br /><br /><br />3. Create a protocol MyProtocol which MyClass conforms to and then make a [MyProtocol] array. This is a little better than the Any array approach in #2 since you can decide which classes implement the protocol, so you get *some* type checking.<br /><br />It's tempting to add an associated type to the protocol so you know something about what's in the array, but Protocols with associated types have the same effective restrictions that Generics do and for the same reasons:<br /><br />protocol MyProtocol {<br />&nbsp; &nbsp; associatedtype MyType<br />}<br /><br />"Protocol 'SettingProtocol' can only be used as a generic constraint because it has Self or associated type requirements".<br /><br />So why not just have an abstract superclass that you can actually put some logic into instead of having to deal with the unreliable nature of default implementations of functions on your protocol?<br /><br />It's also good to know that MyProtocol can't have Self requirements (like Equatable does) if you want to have it be the type of an array. This keeps you from making an array of Equatable which makes sense since you can equate any 2 Doubles, but not a Double and a String. Big Nerd Ranch goes into this in a little more depth: https://www.bignerdranch.com/blog/why-associated-type-requirements-become-generic-constraints/<br /><br />3. The Type Erasure Pattern<br /><a href="https://www.bignerdranch.com/blog/breaking-down-type-erasure-in-swift/">https://www.bignerdranch.com/blog/breaking-down-type-erasure-in-swift/</a><br />The Type Erasure Pattern is a solution to a *different* problem. Instead of letting you make an array of different types, it allows you to make an array of different classes of objects that conform to the same protocol with the <i>same</i> associated type. So it won't let you fake your way to [1, "2", Dictionary] but it will let you effectively make something like [IntHandler(1), DifferentKindOfIntHandler(1), VeryDifferentIntHandler(1)].<br /><br />Since Type Erasure Pattern essentially substitutes a class for the protocol, to me this seems functionally equivalent to making an abstract generic class MyClass<type> and then making an array of MyClass<int> but with extra steps. The payoff for those steps is that you then get to effectively use a protocol instead of a class which can be a big help in a complex project, but YAGNI, probably.</int></type><br /><br />Note: Type Erasure is a CS term that in swift means "use generics", and the Type Erasure Pattern is a particular software design pattern relying heavily on the use of generics.<br /><br />4. Enums with associated values<br /><br />From https://github.com/VinceBurn/SwiftyPlist/blob/master/Pod/Classes/Plist.swift:<br /><br />&nbsp; &nbsp; enum EntityType {<br />&nbsp; &nbsp; &nbsp; &nbsp; case string(String)<br />&nbsp; &nbsp; &nbsp; &nbsp; case number(NSNumber)<br />&nbsp; &nbsp; &nbsp; &nbsp; case date(Date)<br />&nbsp; &nbsp; &nbsp; &nbsp; case data(Data)<br />&nbsp; &nbsp; &nbsp; &nbsp; case array([Plist])<br />&nbsp; &nbsp; &nbsp; &nbsp; case dictionary([String : Plist])<br />&nbsp; &nbsp; }<br /><br />let arr = [EntityType.string("Foo"), EntityType.date(Date())]<br /><br />Interestingly, Enums With Associated Values are how Optionals work in Swift - the compiler creates an enum with the associated value of YourType: https://medium.com/ios-os-x-development/swift-optionals-78dafaa53f3<br /><br />Writing to an enum with an associated type is <i>most</i> elegant but getting a primitive value back out from one requires a lot of awful switch case code. My impulse was to immediately try to encapsulate the accessor code away behind a StringSetting or IntSetting class that knows exactly what data type it's managing and can expose a primitive property. Which brings me back around to my original idea...<br /><br /><br />5. Just make an abstract class with very limited functionality and make subclasses that explicitly expose a primitive of the the type they handle:<br /><br />let arr:[AbstractSetting] = [StringSetting("Foo"), IntSetting(1)]<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />