# What are Actors Good at?

- They completely prevent a type of **race condition** (the order/timing in which you do stuff affecting the outcome) known as a **data race** (accessing a mutable object while another thread is writing to it, crashing your app with EXC_BAD_ACCESS).
- They're async, which means they don't need completion handlers and they can't block MainActor while you're `await`ing some heavy lifting.
- Most importantly, they do so simply and elegantly, although you do tend to need to make a task pool on all but the most basic of actors.

# What New Functionality do Actors Provide?

Actors `isolate` all their member vars and funcs. Isolation is a compile-time thing, and comes in 3 flavors:

- None: Not isolated. The default. It's up to you to make sure that there are no data races. You can opt into this using @nonisolated.
- Static: Specified at compile time. The compiler synthesizes all the data race prevention/thread serialization boilerplate you would have had to write using `DispatchQueue`'s, `Semaphore`s and whatnot. Additionlly, and perhaps most importantly, **the compiler treats it as an error if you try to break isolation boundaries**.
- Dynamic: Still specified at compile time. You make a potentially risky promise that you'll be isolated to a particular Actor, typically from a nonisolated context, such as with `MainActor.assumeIsolated {...}`. This is probably 

Note that because isolation occurs at _compile time_, actors don't actually provide any run-time benefit. You _could_ do everthing an actor can do with a `final class` implementing some some `async` funcs that wrap `DispatchQueue.sync` or `DispatchQueue.async` calls, but that work is error-prone and boring.



# Making The Case for Actors

Take the classic evolution towards DispatchQueue.async. First we start with a simple data store which has the potential for a data race if `user()` and `store()` are called at the same time by different threads:

```
class UserStorage {
    private var users = [User.ID: User]()

    func store(_ user: User) {
        users[user.id] = user
    }

    func user(withID id: User.ID) -> User? {
        users[id]
    }
}
```

The usual fix for this is to wrap everything in DispatchQueue.sync blocks, but this means that we risk "data contention", or a bunch of threads waiting for access. If a thousand interactions are queued up and there's any lag on the `users` var (maybe instead of a dict it's actually reading to/writing from a sqlite db or something), then your app can really start to chug waiting for all the syncs to resolve:

```
class UserStorage {
    private var users = [User.ID: User]()
    private let queue = DispatchQueue(label: "UserStorage.sync")

    func store(_ user: User) {
        queue.sync {
            self.users[user.id] = user
        }
    }

    func user(withID id: User.ID) -> User? {
        queue.sync {
            self.users[id]
        }
    }
}
```

So you use DispatchQueue.async instead, but that means having to use completionHandlers which makes interacting with UserStorage a pain.
```
class UserStorage {
    private var users = [User.ID: User]()
    private let queue = DispatchQueue(label: "UserStorage.sync")

    func store(_ user: User) {
        queue.async {
            self.users[user.id] = user
        }
    }

    func loadUser(
      withID id: User.ID,
      handler: @escaping (User?) -> Void
    ) {
        queue.async {
          handler(self.users[id])
        }
    }
}
```

An actor automatically serializes all access to its properties and methods, which ensures that only one caller can directly interact with the actor at any given time. That in turn gives us complete protection against data races, since all mutations will be performed serially, one after the other.

```
actor UserStorage {
    private var users = [User.ID: User]()

    func store(_ user: User) {
        users[user.id] = user
    }

    func user(withID id: User.ID) -> User? {
        users[id]
    }
}
```



# Reentrancy

Reentrancy is a programming concept where a function or subroutine can be interrupted and then resumed before it finishes executing. This means that the function can be called again before it completes its previous execution.

Actor-isolated functions are reentrant. When an actor-isolated function suspends, reentrancy allows other work to execute on the actor before the original actor-isolated function resumes, which we refer to as interleaving.


```
actor Foo {
  var state = 0

  func work() async {
    // assume it's still 0 at this time
    print(state)

    // Suspension point of `work()`. While we're awaiting the result of doSomeLongWork, 
    await doSomeLongWork() 

    // this is no longer guaranteed to be `0` at this point
    print(state) 
  }
  
  func setState(to newValue: Int) {
    state = newValue
  }
}
```

This eliminates the data race but not the race condition. More than the possibility that someone will call setState() while work() is suspended, it's also possible for something to invoke work() again while work() is suspended.

The solution is a task pool: 

```
actor UserLoader {
    private let storage: UserStorage
    private let urlSession: URLSession
    private let decoder = JSONDecoder()
    private var activeTasks = [User.ID: Task<User, Error>]()

    ...

    func loadUser(withID id: User.ID) async throws -> User {
        if let existingTask = activeTasks[id] {
    return try await existingTask.value
}

        let task = Task<User, Error> {
            if let storedUser = await storage.user(withID: id) {
                activeTasks[id] = nil
                return storedUser
            }
        
            let url = URL.forLoadingUser(withID: id)
            
            do {
                let (data, _) = try await urlSession.data(from: url)
                let user = try decoder.decode(User.self, from: data)

                await storage.store(user)
                activeTasks[id] = nil
                return user
            } catch {
                activeTasks[id] = nil
                throw error
            }
        }

        activeTasks[id] = task

return try await task.value
    }
}
```







# Sources
- https://www.swiftbysundell.com/articles/swift-actors/
- https://forums.swift.org/t/actor-reentrancy/59484/7
- https://www.massicotte.org/intro-to-isolation
