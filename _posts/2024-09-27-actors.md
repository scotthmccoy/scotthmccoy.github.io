

# What are Actors Good at?

They prevent **data races**, which are a type of **race condition**. 

- Race Condition: The order/timing in which you do stuff matters
- Data Race: Accesses to a mutable object while another thread is writing to it.

For example, this has the potential for a data race. The users dict could be read from while another thread writes to it, a classic EXC_BAD_ACCESS:
```
class UserStorage {
    private var users = [User.ID: User]()

    func store(_ user: User) {
        users[user.id] = user
    }

    func user(withID id: User.ID) -> User? {
        users[id]
    }
}
```

The usual response to this is to wrap everything in DispatchQueue.sync blocks, but this means that we risk "data contention", or a bunch of threads waiting for access. If a thousand interactions are queued up and there's any lag on the `users` var (maybe instead of a dict it's actually reading to/writing from a sqlite db or something), then your app can really start to chug:
```
class UserStorage {
    private var users = [User.ID: User]()
    private let queue = DispatchQueue(label: "UserStorage.sync")

    func store(_ user: User) {
        queue.sync {
            self.users[user.id] = user
        }
    }

    func user(withID id: User.ID) -> User? {
        queue.sync {
            self.users[id]
        }
    }
}
```

So the typical solution for that is to use async queues, but that means having to use completionHandlers which makes interacting with UserStorage a pain.
```
class UserStorage {
    private var users = [User.ID: User]()
    private let queue = DispatchQueue(label: "UserStorage.sync")

    func store(_ user: User) {
        queue.async {
            self.users[user.id] = user
        }
    }

    func loadUser(
      withID id: User.ID,
      handler: @escaping (User?) -> Void
    ) {
        queue.async {
          handler(self.users[id])
        }
    }
}
```


```
actor UserStorage {
    private var users = [User.ID: User]()

    func store(_ user: User) {
        users[user.id] = user
    }

    func user(withID id: User.ID) -> User? {
        users[id]
    }
}
```


# How Do They Do That?

An actor automatically serializes all access to its properties and methods, which ensures that only one caller can directly interact with the actor at any given time. That in turn gives us complete protection against data races, since all mutations will be performed serially, one after the other.



# Reentrancy

Reentrancy is a programming concept where a function or subroutine can be interrupted and then resumed before it finishes executing. This means that the function can be called again before it completes its previous execution.

Actor-isolated functions are reentrant. When an actor-isolated function suspends, reentrancy allows other work to execute on the actor before the original actor-isolated function resumes, which we refer to as interleaving.


```
actor Foo {
  var state = 0

  func work() async {
    // assume it's still 0 at this time
    print(state)

    // Suspension point of `work()`. While we're awaiting the result of doSomeLongWork, 
    await doSomeLongWork() 

    // this is no longer guaranteed to be `0` at this point
    print(state) 
  }
  
  func setState(to newValue: Int) {
    state = newValue
  }
}
```

More than the possibility that someone will call setState() while work() is suspended, it's also possible for something to invoke work() again while work() is suspended.



# Sources
- https://www.swiftbysundell.com/articles/swift-actors/
- https://forums.swift.org/t/actor-reentrancy/59484/7
