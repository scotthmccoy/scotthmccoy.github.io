---
layout: post
title: Bash - script command to capture stdout, stderr and exit code.
date: '2017-12-27T12:27:00.002-08:00'
author: Scott McCoy
tags: 
modified_time: '2017-12-27T12:27:48.008-08:00'
blogger_id: tag:blogger.com,1999:blog-250956833460526415.post-4283378541533417160
blogger_orig_url: https://scotthmccoy.blogspot.com/2017/12/bash-script-command-to-capture-stdout.html
---

<span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#Capture stdout, stderr and the exit value.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#Unfortunately pipes and redirects have some nasty limitations. When capturing&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#stdout and stderr to a terminal, both streams are line-buffered which means the&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#order of output is preserved. But When writing to a file, stdout switches to page</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#buffering, which means some lines show up out of proper order.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#The current "Best Practices" solution is to use the&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#"tee" command combined with exiting with ${PIPESTATUS[0]} to preserve the exit&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#value. Sadly, tee takes its input from a pipe which means it fails to capture&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#stderr, unless its input already had the streams merged, which results in&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#out-of-order lines as well.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#Thus, we turn to the script command. It simulates a terminal, (meaning we get to</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#enjoy line-buffering), and it also preserves the exit code:</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">output=$(script output.log $1)</span>